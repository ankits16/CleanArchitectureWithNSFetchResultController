//
//  MovieListInteractor.swift
//  TMDB
//
//  Created by ankit on 15/07/17.
//  Copyright (c) 2017 test. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData

protocol MovieListBusinessLogic{
    func fetchMovieListFromServer(request : MovieList.FetchMovieList.Request)
    func applyPredicateToMovieList(request : MovieList.ApplyPredicate.Request)
}

protocol MovieListDataStore{
    func numberOfMovies() -> NSInteger
    func movieAt(indexpath : IndexPath) -> Movie?
    func posterImageForMovie(url: URL , completionHandler: @escaping ImageFetchCompletionHandler)
}

class MovieListInteractor:  NSObject, MovieListBusinessLogic
{
    var presenter: MovieListPresentationLogic?
    var imageFetchWorker = PosterImageWorker()
    var apiWorker: MovieListWorker = MovieListWorker(moviesStore: MoviesAPI())
    var storeWorker : MovieListWorker = MovieListWorker(moviesStore: MoviesCoreDataStore())
    var frc : NSFetchedResultsController<ManagedMovie>?
    var blockOperations: [BlockOperation] = []
    var filterPredicate : NSPredicate?
    
    func initializeFRC()  {
        NSFetchedResultsController<ManagedMovie>.deleteCache(withName: "Root")
        let fetchRequest = NSFetchRequest<ManagedMovie>(entityName: "ManagedMovie")
        let sortDescriptor = NSSortDescriptor(key: "createdTimeStamp", ascending: true)
        
        //fetchRequest.predicate = self.filterPredicate
        fetchRequest.sortDescriptors = [sortDescriptor]
        if let managedObjectContext = (storeWorker.moviesStore as? MoviesCoreDataStore)?.mainManagedObjectContext{
            if frc == nil {
                frc = NSFetchedResultsController(fetchRequest: fetchRequest , managedObjectContext: managedObjectContext, sectionNameKeyPath: nil, cacheName: nil)
                frc?.delegate = self
            }
            
            frc?.fetchRequest.predicate = self.filterPredicate
        }
        
        do {
            try frc?.performFetch()
        }catch{
            print("Error in fetching data")
        }
    }
    
    // MARK : Fetch Movie list
    func fetchMovieListFromServer(request : MovieList.FetchMovieList.Request){
        apiWorker.fetchMovies(pageNuber: request.pageNumber) { (result : MoviesStoreResult<[Movie]>) in
            switch (result){
            case .Success(let fetchedMovies) :
                print("create core data objects")
                self.saveFetchedMoviesToStore(fetchedMovies: fetchedMovies)
                
                
            case .Failure(let error) :
                let response = MovieList.FetchMovieList.Response(error: error.localizedDescription)
                self.presenter?.presentFetchedMovies(response: response)
                
            }
        }
    }
    func applyPredicateToMovieList(request : MovieList.ApplyPredicate.Request){
        self.filterPredicate = request.generatedPredicate
        initializeFRC()
    }
    
    
    // MARK : save fetched movies to local store
    func saveFetchedMoviesToStore(fetchedMovies : [Movie] ) {
        for aMovie in fetchedMovies {
            if (self.frc == nil){
                self.initializeFRC()
            }
            self.storeWorker.createMovie(movieToCreate: aMovie, completionHandler: { (result) in
            })
        }
        (self.storeWorker.moviesStore as? MoviesCoreDataStore)?.saveToDisk()
    }
    
}

extension MovieListInteractor : MovieListDataStore{
    func numberOfMovies() -> NSInteger {
        guard let sections = frc?.sections else {
            print("No sections in fetchedResultsController")
            return 0
        }
        let sectionInfo = sections[0]
        
        return sectionInfo.numberOfObjects
    }
    func movieAt(indexpath: IndexPath) -> Movie? {
        
        if let managedMovie = self.frc?.object(at: indexpath) {
            return managedMovie.toMovie()
        }
        return nil
    }
    func posterImageForMovie(url: URL , completionHandler: @escaping ImageFetchCompletionHandler){
        imageFetchWorker.fetchImage(url: url, completionHandler: completionHandler)
    }
}

extension MovieListInteractor : NSFetchedResultsControllerDelegate{
    public func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>){
        //self.collectionView?.numberOfItems(inSection: 0)
        print("here--------------------------------------------------")
        self.blockOperations.removeAll(keepingCapacity: false)
    }
    
    public func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?){
        switch type {
        case .insert:
            blockOperations.append(
                BlockOperation(block: {[weak self] in
                    if let this = self {
                     guard let managedMovie = this.frc?.object(at: newIndexPath! as IndexPath) else { fatalError("Unexpected Object in FetchedResultsController") }
                        DispatchQueue.main.async {
                            self?.presenter?.presentInsertedMovie(response: MovieList.InsertedMovie.Response(formatteMovie: managedMovie.toMovie(), indexPath: newIndexPath!))
                        }
                    }
                    
                })
            )
        case .delete:
            blockOperations.append(
                BlockOperation(block: { [weak self] in
                    /*if let this = self {
                     print("Core: item deleted at \(indexPath)")
                     this.collectionView!.deleteItems(at: [indexPath!])
                     }*/
                })
            )
        case .update:
            blockOperations.append(
                BlockOperation(block: { [weak self] in
                    /* if let this = self {
                     guard let storyboard = this.frc?.object(at: indexPath! as IndexPath) else { fatalError("Unexpected Object in FetchedResultsController") }
                     
                     print("Core:update item At : \(indexPath) : progress is \((storyboard as Storyboard).segmentsImageDownloadProgress) : is recordable : \((storyboard as Storyboard).isAllSegmentImageDownloaded)")
                     
                     this.collectionView!.reloadItems(at: [indexPath!])
                     }*/
                })
            )
            
        case .move:
            blockOperations.append(
                BlockOperation(block: { [weak self] in
                    /*if let this = self {
                     print("Core:move item At : \(indexPath) to :\(newIndexPath)")
                     this.collectionView!.moveItem(at: indexPath!, to: newIndexPath!)
                     }*/
                })
            )
        }
    }
    
    public func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>){
        for operation: BlockOperation in self.blockOperations {
            operation.start()
        }
        self.blockOperations.removeAll(keepingCapacity: false)
    }
    
}
